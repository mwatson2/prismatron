#!/usr/bin/env python3
"""
Diffusion Pattern Visualization Tool.

This tool creates a web interface to visualize LED diffusion patterns using
the new nested storage format with LEDDiffusionCSCMatrix and SingleBlockMixedSparseTensor.

Features:
1. Grid view of all LED patterns
2. Individual LED/channel navigation
3. Support for both CSC matrix and mixed tensor formats
4. Interactive controls and pattern comparison
5. Comprehensive pattern statistics

Supported format:
- New nested format: NPZ with diffusion_matrix (LEDDiffusionCSCMatrix),
  mixed_tensor (SingleBlockMixedSparseTensor), and metadata

Usage:
    python visualize_diffusion_patterns.py --patterns patterns.npz \\
        --host 0.0.0.0 --port 8080
"""

import argparse
import base64
import io
import logging
import sys
import threading
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import numpy as np
import scipy.sparse as sp
from flask import Flask, jsonify, render_template_string, request, send_from_directory, send_file

try:
    from PIL import Image

    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

# Import constants directly to avoid relative import issues
FRAME_HEIGHT = 480
FRAME_WIDTH = 800
LED_COUNT = 2600

# Import specific modules directly to avoid __init__.py issues
sys.path.append(str(Path(__file__).parent.parent / "src" / "utils"))
from led_diffusion_csc_matrix import LEDDiffusionCSCMatrix
from single_block_sparse_tensor import SingleBlockMixedSparseTensor

logger = logging.getLogger(__name__)


class DiffusionPatternVisualizer:
    """Web-based diffusion pattern visualization tool using new wrapper classes."""

    def __init__(self, patterns_file: Optional[str] = None):
        """
        Initialize visualizer.

        Args:
            patterns_file: Path to patterns file (.npz) in new nested format
        """
        self.patterns_file = patterns_file

        # Wrapper objects for the new format
        self.diffusion_matrix: Optional[LEDDiffusionCSCMatrix] = None
        self.mixed_tensor: Optional[SingleBlockMixedSparseTensor] = None

        # Cached dense patterns for visualization
        self.dense_patterns_csc: Optional[np.ndarray] = None
        self.dense_patterns_mixed: Optional[np.ndarray] = None

        # Metadata and LED info
        self.metadata: Dict = {}
        self.led_positions: Optional[np.ndarray] = None
        self.led_spatial_mapping: Optional[Dict] = None
        self.dense_ata_data: Optional[Dict] = None
        self.dia_matrix_data: Optional[Dict] = None
        self.ata_inverse_data: Optional[np.ndarray] = None

        # Image directories
        self.source_images_dir = Path("images/source")
        self.optimized_images_dir = Path("images/optimized")

        # Flask app
        self.app = Flask(__name__)
        self.app.logger.setLevel(logging.WARNING)  # Reduce Flask logging

        # Setup routes
        self._setup_routes()

    def load_patterns(self) -> bool:
        """Load diffusion patterns from new nested format file."""
        try:
            if not self.patterns_file or not Path(self.patterns_file).exists():
                logger.error("No patterns file provided or file does not exist")
                logger.error(
                    "Generate patterns first with: python tools/generate_synthetic_patterns.py --output patterns.npz"
                )
                return False

            logger.info(f"Loading patterns from {self.patterns_file}")

            # Load the nested format data
            data = np.load(self.patterns_file, allow_pickle=True)

            # Check for new nested format
            if not all(key in data for key in ["diffusion_matrix", "mixed_tensor", "metadata"]):
                logger.error("File does not contain the new nested format")
                logger.error("Expected keys: diffusion_matrix, mixed_tensor, metadata")
                logger.error(f"Found keys: {list(data.keys())}")
                logger.error("Please regenerate patterns with the updated generate_synthetic_patterns.py")
                return False

            logger.info("Detected new nested format, loading wrapper objects...")
            return self._load_nested_format(data)

        except Exception as e:
            logger.error(f"Failed to load patterns: {e}")
            import traceback

            logger.error(traceback.format_exc())
            return False

    def _load_nested_format(self, data: np.lib.npyio.NpzFile) -> bool:
        """Load patterns from new nested format."""
        try:
            # Load LEDDiffusionCSCMatrix
            logger.info("Loading LEDDiffusionCSCMatrix...")
            diffusion_matrix_dict = data["diffusion_matrix"].item()
            self.diffusion_matrix = LEDDiffusionCSCMatrix.from_dict(diffusion_matrix_dict)
            logger.info(f"Loaded diffusion matrix: {self.diffusion_matrix}")

            # Load SingleBlockMixedSparseTensor
            logger.info("Loading SingleBlockMixedSparseTensor...")
            mixed_tensor_dict = data["mixed_tensor"].item()
            self.mixed_tensor = SingleBlockMixedSparseTensor.from_dict(mixed_tensor_dict)
            logger.info(f"Loaded mixed tensor: {self.mixed_tensor}")

            # Load metadata
            self.metadata = data["metadata"].item() if "metadata" in data else {}

            # Load LED positions and spatial mapping
            self.led_positions = data.get("led_positions", None)
            self.led_spatial_mapping = data.get("led_spatial_mapping", None)
            if self.led_spatial_mapping is not None and hasattr(self.led_spatial_mapping, "item"):
                self.led_spatial_mapping = self.led_spatial_mapping.item()

            # Load dense A^T@A data if available
            self.dense_ata_data = data.get("dense_ata", None)
            if self.dense_ata_data is not None and hasattr(self.dense_ata_data, "item"):
                self.dense_ata_data = self.dense_ata_data.item()

            # Load DIA matrix data if available
            self.dia_matrix_data = data.get("dia_matrix", None)
            if self.dia_matrix_data is not None and hasattr(self.dia_matrix_data, "item"):
                self.dia_matrix_data = self.dia_matrix_data.item()

            # Load ATA inverse data if available
            self.ata_inverse_data = data.get("ata_inverse", None)

            # Convert to dense patterns for visualization using new methods
            logger.info("Converting to dense patterns for visualization...")
            self.dense_patterns_csc = self.diffusion_matrix.to_dense_patterns()
            self.dense_patterns_mixed = self.mixed_tensor.to_dense_patterns()

            logger.info(f"CSC dense patterns shape: {self.dense_patterns_csc.shape}")
            logger.info(f"Mixed tensor dense patterns shape: {self.dense_patterns_mixed.shape}")

            return True

        except Exception as e:
            logger.error(f"Failed to load nested format: {e}")
            import traceback

            logger.error(traceback.format_exc())
            return False

    def _setup_routes(self):
        """Setup Flask routes for the new wrapper-based visualization."""

        @self.app.route("/")
        def index():
            """Main visualization page."""
            return render_template_string(HTML_TEMPLATE)

        @self.app.route("/api/metadata")
        def get_metadata():
            """Get pattern metadata using wrapper classes."""
            if not self.diffusion_matrix or not self.mixed_tensor:
                return jsonify({"error": "No patterns loaded"}), 404

            # Get actual LED count from wrapper objects
            led_count_csc = self.diffusion_matrix.led_count
            led_count_mixed = self.mixed_tensor.batch_size

            # Use CSC matrix as authoritative source
            actual_led_count = led_count_csc

            metadata_response = {
                "metadata": self.metadata,
                "led_count": actual_led_count,
                "frame_width": self.diffusion_matrix.width,
                "frame_height": self.diffusion_matrix.height,
                "channels": self.diffusion_matrix.channels,
                "patterns_loaded": True,
                "has_both_formats": True,  # Always true for new format
                "supports_storage_order": self.led_spatial_mapping is not None,
            }

            # Add CSC matrix info using wrapper methods
            if self.diffusion_matrix:
                summary = self.diffusion_matrix.get_pattern_summary()
                memory_info = self.diffusion_matrix.memory_info()

                metadata_response["csc_info"] = {
                    "matrix_shape": summary["matrix_shape"],
                    "nnz": summary["nnz_total"],
                    "sparsity_percent": summary["sparsity_ratio"] * 100,
                    "memory_mb": memory_info["total_mb"],
                    "led_count": summary["led_count"],
                    "channels": summary["channels"],
                }

            # Add mixed tensor info using wrapper methods
            if self.mixed_tensor:
                block_summary = self.mixed_tensor.get_block_summary()
                memory_info = self.mixed_tensor.memory_info()

                metadata_response["mixed_tensor_info"] = {
                    "batch_size": block_summary["batch_size"],
                    "channels": block_summary["channels"],
                    "height": self.mixed_tensor.height,
                    "width": self.mixed_tensor.width,
                    "block_size": block_summary["block_size"],
                    "total_blocks": block_summary["total_blocks"],
                    "memory_mb": memory_info["total_mb"],
                }

            # Add dense A^T@A info if available
            if self.dense_ata_data:
                metadata_response["dense_ata_info"] = {
                    "shape": list(self.dense_ata_data["dense_ata_matrices"].shape),
                    "memory_mb": self.dense_ata_data["dense_ata_matrices"].nbytes / (1024 * 1024),
                    "computation_time": self.dense_ata_data["dense_ata_computation_time"],
                }

            # Add DIA matrix info if available
            if self.dia_matrix_data:
                metadata_response["dia_matrix_info"] = {
                    "led_count": self.dia_matrix_data["led_count"],
                    "bandwidth": self.dia_matrix_data["bandwidth"],
                    "k_diagonals": self.dia_matrix_data["k"],
                    "sparsity": self.dia_matrix_data["sparsity"],
                    "version": self.dia_matrix_data["version"],
                }
                if "dia_data_3d" in self.dia_matrix_data:
                    dia_shape = self.dia_matrix_data["dia_data_3d"].shape
                    metadata_response["dia_matrix_info"]["dia_data_shape"] = list(dia_shape)
                    metadata_response["dia_matrix_info"]["memory_mb"] = self.dia_matrix_data["dia_data_3d"].nbytes / (1024 * 1024)

            # Add ATA inverse info if available
            if self.ata_inverse_data is not None:
                metadata_response["ata_inverse_info"] = {
                    "shape": list(self.ata_inverse_data.shape),
                    "memory_mb": self.ata_inverse_data.nbytes / (1024 * 1024),
                    "dtype": str(self.ata_inverse_data.dtype),
                }

            return jsonify(metadata_response)

        @self.app.route("/api/patterns")
        def get_patterns():
            """Get pattern list with thumbnails using cached dense patterns."""
            if self.dense_patterns_csc is None or self.dense_patterns_mixed is None:
                return jsonify({"error": "No patterns loaded"}), 404

            try:
                page = int(request.args.get("page", 0))
                per_page = int(request.args.get("per_page", 50))
                channel = request.args.get("channel", "all")
                order = request.args.get("order", "numerical")  # "numerical" or "storage"
                format_type = request.args.get("format", "csc")  # "csc" or "mixed"

                # Use CSC matrix as authoritative for LED count
                actual_led_count = self.diffusion_matrix.led_count

                patterns = []
                start_idx = page * per_page
                end_idx = min(start_idx + per_page, actual_led_count)

                # Create LED display information based on requested ordering
                if order == "storage" and self.led_spatial_mapping:
                    # Storage order: show LEDs in matrix/file column order (spatial indices)
                    # Dense patterns are indexed by spatial indices, so use directly
                    display_info = [{"spatial_idx": i, "display_id": i} for i in range(actual_led_count)]
                else:
                    # Numerical order: show LEDs in physical ID order (0, 1, 2, ...)
                    # Need to map from physical IDs to spatial indices for array access
                    reverse_mapping = {
                        matrix_idx: physical_id for physical_id, matrix_idx in self.led_spatial_mapping.items()
                    }
                    # Sort by physical ID for display, but keep track of spatial index for array access
                    display_info = [
                        {"spatial_idx": i, "display_id": reverse_mapping.get(i, i)} for i in range(actual_led_count)
                    ]
                    # Sort by display_id (physical LED ID) for numerical order
                    display_info.sort(key=lambda x: x["display_id"])

                # Get the LEDs for this page
                page_info = display_info[start_idx:end_idx]

                # Select pattern data based on format parameter
                if format_type == "mixed":
                    patterns_to_use = self.dense_patterns_mixed
                    format_label = "Mixed Tensor"
                else:
                    patterns_to_use = self.dense_patterns_csc
                    format_label = "CSC Matrix"

                for info in page_info:
                    spatial_idx = info["spatial_idx"]
                    display_id = info["display_id"]
                    if channel == "all":
                        # Create composite RGB image - patterns are (height, width, 3)
                        rgb_pattern = patterns_to_use[spatial_idx]  # Use spatial index for array access
                    else:
                        # Single channel - extract the specific channel
                        channel_idx = {"red": 0, "green": 1, "blue": 2}.get(channel, 0)
                        single_channel = patterns_to_use[spatial_idx, :, :, channel_idx]  # (height, width)
                        rgb_pattern = np.stack([single_channel] * 3, axis=-1)

                    # Create thumbnail
                    thumbnail = self._create_thumbnail(rgb_pattern, size=(150, 90))

                    # Get physical LED ID for this spatial index
                    if self.led_spatial_mapping:
                        reverse_mapping = {
                            matrix_idx: physical_id for physical_id, matrix_idx in self.led_spatial_mapping.items()
                        }
                        physical_led_id = reverse_mapping.get(spatial_idx, spatial_idx)
                    else:
                        physical_led_id = spatial_idx

                    patterns.append(
                        {
                            "led_id": display_id,  # For compatibility with existing click handlers
                            "spatial_idx": spatial_idx,  # Column index in matrix
                            "physical_led_id": physical_led_id,  # Original LED numbering
                            "thumbnail": thumbnail,
                            "max_intensity": float(np.max(rgb_pattern)),
                            "center_of_mass": self._calculate_center_of_mass(rgb_pattern).tolist(),
                        }
                    )

                return jsonify(
                    {
                        "patterns": patterns,
                        "page": page,
                        "per_page": per_page,
                        "total_leds": actual_led_count,
                        "total_pages": (actual_led_count + per_page - 1) // per_page,
                        "order": order,
                        "format": format_type,
                        "format_label": format_label,
                        "supports_storage_order": self.led_spatial_mapping is not None,
                    }
                )

            except Exception as e:
                logger.error(f"Failed to generate patterns: {e}")
                import traceback

                logger.error(traceback.format_exc())
                return jsonify({"error": str(e)}), 500

        @self.app.route("/api/pattern/<int:led_id>")
        def get_pattern_detail(led_id):
            """Get detailed view of specific LED pattern."""
            if self.dense_patterns_csc is None or self.dense_patterns_mixed is None:
                return jsonify({"error": "No patterns loaded"}), 404

            # Get ordering mode to interpret led_id correctly
            order = request.args.get("order", "numerical")

            actual_led_count = self.diffusion_matrix.led_count

            # Map display ID to spatial index for array access
            if order == "storage" or not self.led_spatial_mapping:
                # Storage order: led_id is already a spatial index
                spatial_idx = led_id
                display_id = led_id
            else:
                # Numerical order: led_id is a physical ID, need to find spatial index
                spatial_idx = self.led_spatial_mapping.get(led_id, led_id)
                display_id = led_id

            if spatial_idx >= actual_led_count:
                return jsonify({"error": "Invalid LED ID"}), 400

            try:
                # Get physical LED ID for this spatial index
                if self.led_spatial_mapping:
                    reverse_mapping = {
                        matrix_idx: physical_id for physical_id, matrix_idx in self.led_spatial_mapping.items()
                    }
                    physical_led_id = reverse_mapping.get(spatial_idx, spatial_idx)
                else:
                    physical_led_id = spatial_idx

                pattern_data = {
                    "led_id": display_id,
                    "spatial_idx": spatial_idx,
                    "physical_led_id": physical_led_id,
                    "channels": {},
                    "formats": {},
                }

                channel_names = ["red", "green", "blue"]

                # Process both CSC and mixed tensor formats
                for format_name, patterns_array in [
                    ("csc", self.dense_patterns_csc),
                    ("mixed", self.dense_patterns_mixed),
                ]:
                    format_data = {"channels": {}}

                    for ch_idx, ch_name in enumerate(channel_names):
                        pattern = patterns_array[spatial_idx, :, :, ch_idx]

                        # Full resolution image
                        full_image = self._pattern_to_base64(pattern)

                        # Statistics
                        stats = {
                            "max_intensity": float(np.max(pattern)),
                            "min_intensity": float(np.min(pattern)),
                            "mean_intensity": float(np.mean(pattern)),
                            "std_intensity": float(np.std(pattern)),
                            "center_of_mass": self._calculate_center_of_mass(pattern).tolist(),
                        }

                        format_data["channels"][ch_name] = {
                            "image": full_image,
                            "statistics": stats,
                        }

                    # Create composite RGB view for this format
                    rgb_pattern = patterns_array[spatial_idx]  # Already in (height, width, 3) format

                    format_data["composite"] = {
                        "image": self._create_full_image(rgb_pattern),
                        "statistics": {
                            "max_intensity": float(np.max(rgb_pattern)),
                            "center_of_mass": self._calculate_center_of_mass(rgb_pattern).tolist(),
                        },
                    }

                    pattern_data["formats"][format_name] = format_data

                return jsonify(pattern_data)

            except Exception as e:
                logger.error(f"Failed to get pattern detail: {e}")
                import traceback

                logger.error(traceback.format_exc())
                return jsonify({"error": str(e)}), 500

    def _create_thumbnail(self, pattern: np.ndarray, size: Tuple[int, int]) -> str:
        """Create base64 thumbnail from pattern."""
        try:
            if not PIL_AVAILABLE:
                return ""

            # Normalize pattern to 0-255
            if len(pattern.shape) == 3:
                # RGB pattern
                normalized = np.clip(pattern * 255, 0, 255).astype(np.uint8)
            else:
                # Single channel - convert to RGB
                normalized = np.clip(pattern * 255, 0, 255).astype(np.uint8)
                normalized = np.stack([normalized] * 3, axis=-1)

            # Create PIL image
            img = Image.fromarray(normalized, mode="RGB")

            # Resize to thumbnail size
            img = img.resize(size, Image.Resampling.LANCZOS)

            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format="PNG")
            img_str = base64.b64encode(buffer.getvalue()).decode()

            return f"data:image/png;base64,{img_str}"

        except Exception as e:
            logger.warning(f"Failed to create thumbnail: {e}")
            return ""

    def _create_full_image(self, pattern: np.ndarray) -> str:
        """Create full resolution base64 image from RGB pattern."""
        try:
            if not PIL_AVAILABLE:
                return ""

            # Normalize to 0-255
            normalized = np.clip(pattern * 255, 0, 255).astype(np.uint8)

            # Create PIL image
            img = Image.fromarray(normalized, mode="RGB")

            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format="PNG")
            img_str = base64.b64encode(buffer.getvalue()).decode()

            return f"data:image/png;base64,{img_str}"

        except Exception as e:
            logger.warning(f"Failed to create full image: {e}")
            return ""

    def _pattern_to_base64(self, pattern: np.ndarray) -> str:
        """Convert single channel pattern to base64 grayscale image."""
        try:
            if not PIL_AVAILABLE:
                return ""

            # Normalize to 0-255
            normalized = np.clip(pattern * 255, 0, 255).astype(np.uint8)

            # Create PIL image
            img = Image.fromarray(normalized, mode="L")

            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format="PNG")
            img_str = base64.b64encode(buffer.getvalue()).decode()

            return f"data:image/png;base64,{img_str}"

        except Exception as e:
            logger.warning(f"Failed to convert pattern to base64: {e}")
            return ""

    def _calculate_center_of_mass(self, pattern: np.ndarray) -> np.ndarray:
        """Calculate center of mass for pattern."""
        try:
            if len(pattern.shape) == 3:
                # Multi-channel - use combined intensity
                intensity = np.mean(pattern, axis=-1)
            else:
                intensity = pattern

            # Calculate center of mass
            total_mass = np.sum(intensity)
            if total_mass == 0:
                return np.array(
                    [
                        self.diffusion_matrix.width // 2,
                        self.diffusion_matrix.height // 2,
                    ]
                )

            y_indices, x_indices = np.indices(intensity.shape)
            x_cm = np.sum(x_indices * intensity) / total_mass
            y_cm = np.sum(y_indices * intensity) / total_mass

            return np.array([x_cm, y_cm])

        except Exception:
            return np.array([self.diffusion_matrix.width // 2, self.diffusion_matrix.height // 2])

    def _dia_to_dense(self, dia_data: np.ndarray, dia_offsets: np.ndarray, size: int) -> np.ndarray:
        """Convert DIA format matrix to dense format for visualization."""
        dense = np.zeros((size, size), dtype=dia_data.dtype)

        for i, offset in enumerate(dia_offsets):
            diagonal = dia_data[i, :]

            if offset >= 0:
                # Upper diagonal
                diag_len = min(size - offset, size)
                for j in range(diag_len):
                    if j < len(diagonal) and j + offset < size:
                        dense[j, j + offset] = diagonal[j]
            else:
                # Lower diagonal
                diag_len = min(size + offset, size)
                for j in range(diag_len):
                    if j < len(diagonal) and j - offset < size:
                        dense[j - offset, j] = diagonal[j]

        return dense

    def _matrix_to_image(self, matrix: np.ndarray) -> str:
        """Convert matrix to base64 image for visualization."""
        try:
            if not PIL_AVAILABLE:
                return ""

            # Normalize matrix values to 0-255 range
            matrix_abs = np.abs(matrix)
            if np.max(matrix_abs) > 0:
                normalized = (matrix_abs / np.max(matrix_abs) * 255).astype(np.uint8)
            else:
                normalized = np.zeros_like(matrix_abs, dtype=np.uint8)

            # Create PIL image
            img = Image.fromarray(normalized, mode="L")

            # Resize if matrix is too large for practical display
            if img.size[0] > 1000 or img.size[1] > 1000:
                # Calculate new size maintaining aspect ratio
                max_size = 1000
                ratio = min(max_size / img.size[0], max_size / img.size[1])
                new_size = (int(img.size[0] * ratio), int(img.size[1] * ratio))
                img = img.resize(new_size, Image.Resampling.LANCZOS)

            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format="PNG")
            img_str = base64.b64encode(buffer.getvalue()).decode()

            return f"data:image/png;base64,{img_str}"

        except Exception as e:
            logger.warning(f"Failed to convert matrix to image: {e}")
            return ""

    def _find_image_pairs(self) -> List[Dict[str, str]]:
        """Find source/optimized image pairs."""
        pairs = []

        if not self.source_images_dir.exists():
            logger.warning(f"Source images directory does not exist: {self.source_images_dir}")
            return pairs

        # Find all source images
        supported_extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.tif', '.webp'}
        source_images = []

        for file_path in self.source_images_dir.iterdir():
            if file_path.is_file() and file_path.suffix.lower() in supported_extensions:
                source_images.append(file_path)

        # Sort for consistent ordering
        source_images.sort()

        # For each source image, check if optimized version exists
        for source_path in source_images:
            source_name = source_path.name

            # Generate expected optimized filename
            stem = source_path.stem
            suffix = source_path.suffix
            optimized_name = f"{stem}_optimized{suffix}"
            optimized_path = self.optimized_images_dir / optimized_name

            # Create pair info
            pair_info = {
                "source_name": source_name,
                "source_path": f"/api/image/{source_name}",
                "optimized_name": optimized_name if optimized_path.exists() else None,
                "optimized_path": f"/api/image/{optimized_name}" if optimized_path.exists() else None,
                "has_optimized": optimized_path.exists(),
                "source_size": source_path.stat().st_size if source_path.exists() else 0,
                "optimized_size": optimized_path.stat().st_size if optimized_path.exists() else 0,
            }

            pairs.append(pair_info)

        logger.info(f"Found {len(pairs)} image pairs ({sum(1 for p in pairs if p['has_optimized'])} with optimized versions)")
        return pairs

    def run(self, host: str = "127.0.0.1", port: int = 8080, debug: bool = False):
        """Run the web server."""
        if not self.load_patterns():
            logger.error("Failed to load patterns")
            return

        logger.info(f"Starting diffusion pattern visualizer at http://{host}:{port}")
        self.app.run(host=host, port=port, debug=debug, threaded=True)


# HTML Template for the web interface
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion Pattern Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #2a2a2a;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select, input, button {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            color: #fff;
        }

        button {
            background-color: #0066cc;
            cursor: pointer;
        }

        button:hover {
            background-color: #0052a3;
        }

        .metadata {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .metadata h3 {
            margin-top: 0;
            color: #4CAF50;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .pattern-card {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .pattern-card:hover {
            background-color: #3a3a3a;
        }

        .pattern-card img {
            width: 100%;
            height: auto;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .pattern-info {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .pagination button {
            padding: 8px 16px;
        }

        .pagination button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #2a2a2a;
            margin: 2% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #fff;
        }

        .pattern-detail {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .channel-images {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .channel-image {
            text-align: center;
        }

        .channel-image img {
            width: 100%;
            max-width: 300px;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .statistics {
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .error {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
            background-color: #2a1a1a;
            border-radius: 8px;
            border: 1px solid #ff6b6b;
        }

        .format-toggle {
            background-color: #333;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .format-button {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
            border-radius: 4px;
        }

        .format-button.active {
            background-color: #0066cc;
        }

        .ata-section {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .ata-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #333;
            border-radius: 8px;
        }

        .ata-content {
            text-align: center;
        }

        .ata-matrix-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .ata-matrix-image {
            max-width: 100%;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .ata-stats {
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
        }

        .ata-stats h3 {
            margin-top: 0;
            color: #4CAF50;
        }

        .images-section {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .images-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #333;
            border-radius: 8px;
        }

        .images-controls input {
            flex: 1;
            max-width: 300px;
        }

        .images-content {
            text-align: center;
        }

        .image-pairs-grid {
            display: grid;
            gap: 20px;
        }

        .image-pair {
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            align-items: start;
        }

        .image-pair.no-optimized {
            grid-template-columns: 1fr;
        }

        .image-container {
            text-align: center;
        }

        .image-container h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .image-container img {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .image-info {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }

        .no-optimized-notice {
            text-align: center;
            color: #ff9800;
            font-style: italic;
            padding: 20px;
            background-color: #2a2a1a;
            border-radius: 4px;
        }

        @media (max-width: 1200px) {
            .image-pair {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 15px;
            }

            .grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .pattern-detail {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŒˆ Diffusion Pattern Visualizer</h1>
            <p>Interactive viewer for LED diffusion patterns and source/optimized image comparisons</p>
        </div>

        <div id="metadata" class="metadata"></div>

        <div class="format-toggle">
            <button id="csc-btn" class="format-button active" onclick="switchFormat('csc')">CSC Matrix</button>
            <button id="mixed-btn" class="format-button" onclick="switchFormat('mixed')">Mixed Tensor</button>
            <button id="ata-btn" class="format-button" onclick="switchFormat('ata')">ATA Matrix</button>
            <button id="ata-inv-btn" class="format-button" onclick="switchFormat('ata_inverse')">ATA Inverse</button>
            <button id="images-btn" class="format-button" onclick="switchFormat('images')">Image Comparison</button>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="channel">Channel:</label>
                <select id="channel">
                    <option value="all">All (RGB)</option>
                    <option value="red">Red</option>
                    <option value="green">Green</option>
                    <option value="blue">Blue</option>
                </select>
            </div>

            <div class="control-group">
                <label for="order">Order:</label>
                <select id="order">
                    <option value="numerical">Numerical (LED ID)</option>
                    <option value="storage">Storage (Matrix Column)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="per-page">Per page:</label>
                <select id="per-page">
                    <option value="25">25</option>
                    <option value="50" selected>50</option>
                    <option value="100">100</option>
                </select>
            </div>

            <button onclick="refresh()">Refresh</button>
        </div>

        <div class="pagination" id="pagination-top"></div>
        <div id="patterns" class="grid"></div>
        <div class="pagination" id="pagination-bottom"></div>

        <!-- ATA Matrix Visualization -->
        <div id="ata-section" class="ata-section" style="display: none;">
            <h2>A^T A Matrix Visualization</h2>
            <div class="ata-controls">
                <label for="ata-channel">Channel:</label>
                <select id="ata-channel">
                    <option value="0">Red (0)</option>
                    <option value="1">Green (1)</option>
                    <option value="2">Blue (2)</option>
                </select>
                <button onclick="loadATAMatrix()">Load Matrix</button>
            </div>
            <div id="ata-content" class="ata-content">
                <div class="loading">Select a channel and click Load Matrix</div>
            </div>
        </div>

        <!-- ATA Inverse Matrix Visualization -->
        <div id="ata-inverse-section" class="ata-section" style="display: none;">
            <h2>A^T A Inverse Matrix Visualization</h2>
            <div class="ata-controls">
                <label for="ata-inv-channel">Channel:</label>
                <select id="ata-inv-channel">
                    <option value="0">Red (0)</option>
                    <option value="1">Green (1)</option>
                    <option value="2">Blue (2)</option>
                </select>
                <button onclick="loadATAInverseMatrix()">Load Matrix</button>
            </div>
            <div id="ata-inverse-content" class="ata-content">
                <div class="loading">Select a channel and click Load Matrix</div>
            </div>
        </div>

        <!-- Image Comparison Section -->
        <div id="images-section" class="images-section" style="display: none;">
            <h2>Source vs Optimized Image Comparison</h2>
            <div class="images-controls">
                <button onclick="loadImagePairs()">Refresh Image List</button>
                <label for="image-filter">Filter:</label>
                <input type="text" id="image-filter" placeholder="Filter by filename..." onInput="filterImages()">
            </div>
            <div id="images-content" class="images-content">
                <div class="loading">Click Refresh to load image pairs</div>
            </div>
        </div>
    </div>

    <!-- Modal for pattern details -->
    <div id="pattern-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="pattern-detail-content"></div>
        </div>
    </div>

    <script>
        let currentPage = 0;
        let currentChannel = 'all';
        let currentOrder = 'numerical';
        let currentFormat = 'csc';
        let currentATAChannel = 0;
        let currentATAInvChannel = 0;
        let totalPages = 0;
        let perPage = 50;
        let metadata = null;

        // Initialize
        window.onload = function() {
            loadMetadata();
            loadPatterns();

            // Setup modal
            const modal = document.getElementById('pattern-modal');
            const closeBtn = document.getElementsByClassName('close')[0];

            closeBtn.onclick = function() {
                modal.style.display = 'none';
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }

            // Setup controls
            document.getElementById('channel').addEventListener('change', function() {
                currentChannel = this.value;
                currentPage = 0;
                loadPatterns();
            });

            document.getElementById('order').addEventListener('change', function() {
                currentOrder = this.value;
                currentPage = 0;
                loadPatterns();
            });

            document.getElementById('per-page').addEventListener('change', function() {
                perPage = parseInt(this.value);
                currentPage = 0;
                loadPatterns();
            });
        };

        function switchFormat(format) {
            currentFormat = format;
            currentPage = 0;

            // Update button styles
            document.getElementById('csc-btn').classList.toggle('active', format === 'csc');
            document.getElementById('mixed-btn').classList.toggle('active', format === 'mixed');
            document.getElementById('ata-btn').classList.toggle('active', format === 'ata');
            document.getElementById('ata-inv-btn').classList.toggle('active', format === 'ata_inverse');
            document.getElementById('images-btn').classList.toggle('active', format === 'images');

            // Show/hide appropriate sections
            document.getElementById('patterns').style.display =
                (format === 'csc' || format === 'mixed') ? 'grid' : 'none';
            document.getElementById('pagination-top').style.display =
                (format === 'csc' || format === 'mixed') ? 'flex' : 'none';
            document.getElementById('pagination-bottom').style.display =
                (format === 'csc' || format === 'mixed') ? 'flex' : 'none';
            document.getElementById('ata-section').style.display =
                format === 'ata' ? 'block' : 'none';
            document.getElementById('ata-inverse-section').style.display =
                format === 'ata_inverse' ? 'block' : 'none';
            document.getElementById('images-section').style.display =
                format === 'images' ? 'block' : 'none';

            if (format === 'csc' || format === 'mixed') {
                loadPatterns();
            }
        }

        function loadMetadata() {
            fetch('/api/metadata')
                .then(response => response.json())
                .then(data => {
                    metadata = data;
                    displayMetadata(data);

                    // Update order control visibility
                    const orderSelect = document.getElementById('order');
                    orderSelect.style.display = data.supports_storage_order ? 'block' : 'none';
                    if (!data.supports_storage_order) {
                        orderSelect.parentElement.style.display = 'none';
                    }

                    // Update ATA button visibility based on available data
                    const ataBtn = document.getElementById('ata-btn');
                    const ataInvBtn = document.getElementById('ata-inv-btn');
                    ataBtn.style.display = data.dia_matrix_info ? 'inline-block' : 'none';
                    ataInvBtn.style.display = data.ata_inverse_info ? 'inline-block' : 'none';

                    // Setup ATA channel change handlers
                    document.getElementById('ata-channel').addEventListener('change', function() {
                        if (currentFormat === 'ata') {
                            loadATAMatrix();
                        }
                    });

                    document.getElementById('ata-inv-channel').addEventListener('change', function() {
                        if (currentFormat === 'ata_inverse') {
                            loadATAInverseMatrix();
                        }
                    });
                })
                .catch(error => {
                    console.error('Error loading metadata:', error);
                    document.getElementById('metadata').innerHTML =
                        '<div class="error">Failed to load metadata: ' + error + '</div>';
                });
        }

        function displayMetadata(data) {
            const metadataDiv = document.getElementById('metadata');

            let html = '<h3>Pattern Information</h3>';
            html += '<div class="stats-grid">';
            html += `<div><strong>LED Count:</strong> ${data.led_count}</div>`;
            html += `<div><strong>Dimensions:</strong> ${data.frame_width} Ã— ${data.frame_height}</div>`;
            html += `<div><strong>Channels:</strong> ${data.channels}</div>`;
            const format_text = data.has_both_formats ? 'CSC Matrix + Mixed Tensor' : 'Single Format';
            html += `<div><strong>Formats:</strong> ${format_text}</div>`;

            if (data.csc_info) {
                const rows = data.csc_info.matrix_shape[0];
                const cols = data.csc_info.matrix_shape[1];
                html += `<div><strong>CSC Matrix:</strong> ${rows} Ã— ${cols}</div>`;
                html += `<div><strong>CSC Memory:</strong> ${data.csc_info.memory_mb.toFixed(1)} MB</div>`;
                html += `<div><strong>CSC Sparsity:</strong> ${data.csc_info.sparsity_percent.toFixed(2)}%</div>`;
                html += `<div><strong>CSC NNZ:</strong> ${data.csc_info.nnz.toLocaleString()}</div>`;
            }

            if (data.mixed_tensor_info) {
                const info = data.mixed_tensor_info;
                const tensor_dims = `${info.batch_size} Ã— ${info.channels} Ã— ${info.height} Ã— ${info.width}`;
                html += `<div><strong>Mixed Tensor:</strong> ${tensor_dims}</div>`;
                html += `<div><strong>Block Size:</strong> ${info.block_size} Ã— ${info.block_size}</div>`;
                html += `<div><strong>Mixed Memory:</strong> ${info.memory_mb.toFixed(1)} MB</div>`;
                html += `<div><strong>Total Blocks:</strong> ${info.total_blocks.toLocaleString()}</div>`;
            }

            if (data.dia_matrix_info) {
                const info = data.dia_matrix_info;
                html += `<div><strong>DIA Matrix:</strong> ${info.led_count} LEDs</div>`;
                html += `<div><strong>DIA Bandwidth:</strong> ${info.bandwidth}</div>`;
                html += `<div><strong>DIA Diagonals:</strong> ${info.k_diagonals}</div>`;
                html += `<div><strong>DIA Memory:</strong> ${info.memory_mb.toFixed(1)} MB</div>`;
            }

            if (data.ata_inverse_info) {
                const info = data.ata_inverse_info;
                html += `<div><strong>ATA Inverse:</strong> ${info.shape[0]} Ã— ${info.shape[1]} Ã— ${info.shape[2]}</div>`;
                html += `<div><strong>ATA Inv Memory:</strong> ${info.memory_mb.toFixed(1)} MB</div>`;
                html += `<div><strong>ATA Inv Type:</strong> ${info.dtype}</div>`;
            }

            html += '</div>';

            metadataDiv.innerHTML = html;
        }

        function loadPatterns() {
            const patternsDiv = document.getElementById('patterns');
            patternsDiv.innerHTML = '<div class="loading">Loading patterns...</div>';

            const params = new URLSearchParams({
                page: currentPage,
                per_page: perPage,
                channel: currentChannel,
                order: currentOrder,
                format: currentFormat
            });

            fetch(`/api/patterns?${params}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    displayPatterns(data);
                    setupPagination(data);
                })
                .catch(error => {
                    console.error('Error loading patterns:', error);
                    patternsDiv.innerHTML =
                        '<div class="error">Failed to load patterns: ' + error + '</div>';
                });
        }

        function displayPatterns(data) {
            const patternsDiv = document.getElementById('patterns');

            if (data.patterns.length === 0) {
                patternsDiv.innerHTML = '<div class="loading">No patterns to display</div>';
                return;
            }

            let html = '';
            data.patterns.forEach(pattern => {
                html += `
                    <div class="pattern-card" onclick="showPatternDetail(${pattern.led_id})">
                        <img src="${pattern.thumbnail}" alt="COL ${pattern.spatial_idx} LED ${pattern.physical_led_id}">
                        <div class="pattern-info">
                            <div><strong>COL ${pattern.spatial_idx} LED ${pattern.physical_led_id}</strong></div>
                            <div>Max: ${pattern.max_intensity.toFixed(3)}</div>
                            <div>CM: (${pattern.center_of_mass[0].toFixed(1)},
                                     ${pattern.center_of_mass[1].toFixed(1)})</div>
                        </div>
                    </div>
                `;
            });

            patternsDiv.innerHTML = html;
        }

        function setupPagination(data) {
            totalPages = data.total_pages;
            currentPage = data.page;

            const paginationHTML = `
                <button onclick="goToPage(0)" ${currentPage === 0 ? 'disabled' : ''}>First</button>
                <button onclick="goToPage(${currentPage - 1})" ${currentPage === 0 ? 'disabled' : ''}>Previous</button>
                <span>Page ${currentPage + 1} of ${totalPages} (${data.total_leds} LEDs, ${data.format_label})</span>
                <button onclick="goToPage(${currentPage + 1})"
                        ${currentPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>
                <button onclick="goToPage(${totalPages - 1})"
                        ${currentPage >= totalPages - 1 ? 'disabled' : ''}>Last</button>
            `;

            document.getElementById('pagination-top').innerHTML = paginationHTML;
            document.getElementById('pagination-bottom').innerHTML = paginationHTML;
        }

        function goToPage(page) {
            if (page >= 0 && page < totalPages) {
                currentPage = page;
                loadPatterns();
            }
        }

        function showPatternDetail(ledId) {
            const modal = document.getElementById('pattern-modal');
            const content = document.getElementById('pattern-detail-content');

            content.innerHTML = '<div class="loading">Loading pattern details...</div>';
            modal.style.display = 'block';

            fetch(`/api/pattern/${ledId}?order=${currentOrder}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    displayPatternDetail(data);
                })
                .catch(error => {
                    console.error('Error loading pattern detail:', error);
                    content.innerHTML =
                        '<div class="error">Failed to load pattern details: ' + error + '</div>';
                });
        }

        @self.app.route("/api/ata_matrix/<int:channel>")
        def get_ata_matrix(channel):
            """Get ATA matrix visualization for a specific channel."""
            if self.dia_matrix_data is None:
                return jsonify({"error": "No DIA matrix data available"}), 404

            if channel < 0 or channel >= 3:
                return jsonify({"error": "Invalid channel, must be 0, 1, or 2"}), 400

            try:
                # Get the DIA matrix data for this channel
                dia_data = self.dia_matrix_data["dia_data_3d"][channel]  # Shape: (k, led_count)
                dia_offsets = self.dia_matrix_data["dia_offsets_3d"]  # Shape: (k,)
                led_count = self.dia_matrix_data["led_count"]

                # Convert DIA format to dense for visualization
                dense_matrix = self._dia_to_dense(dia_data, dia_offsets, led_count)

                # Create visualization image
                matrix_image = self._matrix_to_image(dense_matrix)

                return jsonify({
                    "channel": channel,
                    "matrix_shape": list(dense_matrix.shape),
                    "matrix_image": matrix_image,
                    "bandwidth": self.dia_matrix_data["bandwidth"],
                    "k_diagonals": self.dia_matrix_data["k"],
                    "sparsity": self.dia_matrix_data["sparsity"],
                    "max_value": float(np.max(dense_matrix)),
                    "min_value": float(np.min(dense_matrix)),
                    "nnz": int(np.count_nonzero(dense_matrix)),
                })

            except Exception as e:
                logger.error(f"Failed to get ATA matrix: {e}")
                import traceback
                logger.error(traceback.format_exc())
                return jsonify({"error": str(e)}), 500

        @self.app.route("/api/ata_inverse/<int:channel>")
        def get_ata_inverse(channel):
            """Get ATA inverse matrix visualization for a specific channel."""
            if self.ata_inverse_data is None:
                return jsonify({"error": "No ATA inverse data available"}), 404

            if channel < 0 or channel >= 3:
                return jsonify({"error": "Invalid channel, must be 0, 1, or 2"}), 400

            try:
                # Get the ATA inverse matrix for this channel
                inverse_matrix = self.ata_inverse_data[channel]  # Shape: (led_count, led_count)

                # Create visualization image
                matrix_image = self._matrix_to_image(inverse_matrix)

                return jsonify({
                    "channel": channel,
                    "matrix_shape": list(inverse_matrix.shape),
                    "matrix_image": matrix_image,
                    "max_value": float(np.max(inverse_matrix)),
                    "min_value": float(np.min(inverse_matrix)),
                    "condition_number": float(np.linalg.cond(inverse_matrix)),
                    "determinant": float(np.linalg.det(inverse_matrix)),
                })

            except Exception as e:
                logger.error(f"Failed to get ATA inverse matrix: {e}")
                import traceback
                logger.error(traceback.format_exc())
                return jsonify({"error": str(e)}), 500

        @self.app.route("/api/image_pairs")
        def get_image_pairs():
            """Get list of source/optimized image pairs."""
            try:
                pairs = self._find_image_pairs()
                return jsonify({
                    "pairs": pairs,
                    "total_pairs": len(pairs),
                    "source_dir": str(self.source_images_dir),
                    "optimized_dir": str(self.optimized_images_dir),
                })
            except Exception as e:
                logger.error(f"Failed to get image pairs: {e}")
                return jsonify({"error": str(e)}), 500

        @self.app.route("/api/image/<path:image_name>")
        def serve_image(image_name):
            """Serve an image file from source or optimized directories."""
            try:
                # Check if it's a source or optimized image
                if image_name.endswith('_optimized.jpg') or image_name.endswith('_optimized.png') or image_name.endswith('_optimized.jpeg'):
                    # Optimized image
                    image_path = self.optimized_images_dir / image_name
                else:
                    # Source image
                    image_path = self.source_images_dir / image_name

                if not image_path.exists():
                    return jsonify({"error": "Image not found"}), 404

                return send_file(image_path)

            except Exception as e:
                logger.error(f"Failed to serve image {image_name}: {e}")
                return jsonify({"error": str(e)}), 500

        function displayPatternDetail(data) {
            const content = document.getElementById('pattern-detail-content');

            let html = `<h2>COL ${data.spatial_idx} LED ${data.physical_led_id} - Pattern Details</h2>`;

            // Format tabs
            html += '<div class="format-toggle">';
            Object.keys(data.formats).forEach(format => {
                const isActive = format === 'csc' ? 'active' : '';
                html += `<button class="format-button ${isActive}"
                         onclick="showFormatTab('${format}')">${format.toUpperCase()}</button>`;
            });
            html += '</div>';

            // Format content
            Object.entries(data.formats).forEach(([format, formatData]) => {
                const displayStyle = format === 'csc' ? 'block' : 'none';
                html += `<div id="format-${format}" style="display: ${displayStyle}">`;
                html += '<div class="pattern-detail">';

                // Left side - images
                html += '<div>';
                html += '<h3>Composite RGB</h3>';
                html += `<img src="${formatData.composite.image}"
                         style="width: 100%; max-width: 400px; border: 1px solid #444;">`;

                html += '<h3>Individual Channels</h3>';
                html += '<div class="channel-images">';
                Object.entries(formatData.channels).forEach(([channel, channelData]) => {
                    html += `
                        <div class="channel-image">
                            <h4>${channel.charAt(0).toUpperCase() + channel.slice(1)}</h4>
                            <img src="${channelData.image}" alt="${channel}">
                        </div>
                    `;
                });
                html += '</div></div>';

                // Right side - statistics
                html += '<div><h3>Statistics</h3>';
                html += '<div class="statistics">';
                html += '<h4>Composite</h4>';
                html += '<div class="stats-grid">';
                Object.entries(formatData.composite.statistics).forEach(([key, value]) => {
                    const displayValue = Array.isArray(value) ?
                        `(${value.map(v => v.toFixed(1)).join(', ')})` :
                        (typeof value === 'number' ? value.toFixed(4) : value);
                    html += `<div><strong>${key.replace('_', ' ')}:</strong> ${displayValue}</div>`;
                });
                html += '</div>';

                Object.entries(formatData.channels).forEach(([channel, channelData]) => {
                    html += `<h4>${channel.charAt(0).toUpperCase() + channel.slice(1)} Channel</h4>`;
                    html += '<div class="stats-grid">';
                    Object.entries(channelData.statistics).forEach(([key, value]) => {
                        const displayValue = Array.isArray(value) ?
                            `(${value.map(v => v.toFixed(1)).join(', ')})` :
                            (typeof value === 'number' ? value.toFixed(4) : value);
                        html += `<div><strong>${key.replace('_', ' ')}:</strong> ${displayValue}</div>`;
                    });
                    html += '</div>';
                });

                html += '</div></div></div></div>';
            });

            content.innerHTML = html;
        }

        function showFormatTab(format) {
            // Hide all format tabs
            document.querySelectorAll('[id^="format-"]').forEach(tab => {
                tab.style.display = 'none';
            });

            // Show selected tab
            document.getElementById(`format-${format}`).style.display = 'block';

            // Update button states
            document.querySelectorAll('.format-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function refresh() {
            loadMetadata();
            loadPatterns();
        }

        let imagePairs = [];

        function loadImagePairs() {
            const content = document.getElementById('images-content');

            content.innerHTML = '<div class="loading">Loading image pairs...</div>';

            fetch('/api/image_pairs')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    imagePairs = data.pairs;
                    displayImagePairs(imagePairs);
                })
                .catch(error => {
                    console.error('Error loading image pairs:', error);
                    content.innerHTML = '<div class="error">Failed to load image pairs: ' + error + '</div>';
                });
        }

        function displayImagePairs(pairs) {
            const content = document.getElementById('images-content');

            if (pairs.length === 0) {
                content.innerHTML = '<div class="loading">No images found in images/source directory</div>';
                return;
            }

            let html = '<div class="image-pairs-grid">';

            pairs.forEach(pair => {
                const hasOptimized = pair.has_optimized;
                const pairClass = hasOptimized ? 'image-pair' : 'image-pair no-optimized';

                html += `<div class="${pairClass}">`;

                // Source image
                html += '<div class="image-container">';
                html += '<h4>Source Image</h4>';
                html += `<img src="${pair.source_path}" alt="${pair.source_name}" loading="lazy">`;
                html += '<div class="image-info">';
                html += `<div><strong>File:</strong> ${pair.source_name}</div>`;
                html += `<div><strong>Size:</strong> ${formatFileSize(pair.source_size)}</div>`;
                html += '</div></div>';

                // Optimized image (if exists)
                if (hasOptimized) {
                    html += '<div class="image-container">';
                    html += '<h4>Optimized LED Version</h4>';
                    html += `<img src="${pair.optimized_path}" alt="${pair.optimized_name}" loading="lazy">`;
                    html += '<div class="image-info">';
                    html += `<div><strong>File:</strong> ${pair.optimized_name}</div>`;
                    html += `<div><strong>Size:</strong> ${formatFileSize(pair.optimized_size)}</div>`;
                    html += '</div></div>';
                } else {
                    html += '<div class="no-optimized-notice">';
                    html += '<p>No optimized version available</p>';
                    html += '<p>Run: <code>python tools/batch_image_optimizer.py --pattern-file patterns.npz</code></p>';
                    html += '</div>';
                }

                html += '</div>';
            });

            html += '</div>';

            content.innerHTML = html;
        }

        function filterImages() {
            const filterText = document.getElementById('image-filter').value.toLowerCase();

            if (!imagePairs.length) {
                return;
            }

            const filteredPairs = imagePairs.filter(pair => {
                return pair.source_name.toLowerCase().includes(filterText);
            });

            displayImagePairs(filteredPairs);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';

            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));

            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function loadATAMatrix() {
            const channel = parseInt(document.getElementById('ata-channel').value);
            const content = document.getElementById('ata-content');

            content.innerHTML = '<div class="loading">Loading ATA matrix...</div>';

            fetch(`/api/ata_matrix/${channel}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    displayATAMatrix(data);
                })
                .catch(error => {
                    console.error('Error loading ATA matrix:', error);
                    content.innerHTML = '<div class="error">Failed to load ATA matrix: ' + error + '</div>';
                });
        }

        function displayATAMatrix(data) {
            const content = document.getElementById('ata-content');

            let html = '<div class="ata-matrix-info">';

            // Matrix image
            html += '<div>';
            html += `<h3>Channel ${data.channel} A^T A Matrix</h3>`;
            html += `<img src="${data.matrix_image}" alt="ATA Matrix" class="ata-matrix-image">`;
            html += '</div>';

            // Matrix statistics
            html += '<div class="ata-stats">';
            html += '<h3>Matrix Statistics</h3>';
            html += `<p><strong>Shape:</strong> ${data.matrix_shape[0]} Ã— ${data.matrix_shape[1]}</p>`;
            html += `<p><strong>Bandwidth:</strong> ${data.bandwidth}</p>`;
            html += `<p><strong>Diagonals:</strong> ${data.k_diagonals}</p>`;
            html += `<p><strong>Sparsity:</strong> ${data.sparsity.toFixed(2)}%</p>`;
            html += `<p><strong>Non-zeros:</strong> ${data.nnz.toLocaleString()}</p>`;
            html += `<p><strong>Max Value:</strong> ${data.max_value.toFixed(4)}</p>`;
            html += `<p><strong>Min Value:</strong> ${data.min_value.toFixed(4)}</p>`;
            html += '</div>';

            html += '</div>';

            content.innerHTML = html;
        }

        function loadATAInverseMatrix() {
            const channel = parseInt(document.getElementById('ata-inv-channel').value);
            const content = document.getElementById('ata-inverse-content');

            content.innerHTML = '<div class="loading">Loading ATA inverse matrix...</div>';

            fetch(`/api/ata_inverse/${channel}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    displayATAInverseMatrix(data);
                })
                .catch(error => {
                    console.error('Error loading ATA inverse matrix:', error);
                    content.innerHTML = '<div class="error">Failed to load ATA inverse matrix: ' + error + '</div>';
                });
        }

        function displayATAInverseMatrix(data) {
            const content = document.getElementById('ata-inverse-content');

            let html = '<div class="ata-matrix-info">';

            // Matrix image
            html += '<div>';
            html += `<h3>Channel ${data.channel} A^T A Inverse Matrix</h3>`;
            html += `<img src="${data.matrix_image}" alt="ATA Inverse Matrix" class="ata-matrix-image">`;
            html += '</div>';

            // Matrix statistics
            html += '<div class="ata-stats">';
            html += '<h3>Matrix Statistics</h3>';
            html += `<p><strong>Shape:</strong> ${data.matrix_shape[0]} Ã— ${data.matrix_shape[1]}</p>`;
            html += `<p><strong>Max Value:</strong> ${data.max_value.toFixed(6)}</p>`;
            html += `<p><strong>Min Value:</strong> ${data.min_value.toFixed(6)}</p>`;
            html += `<p><strong>Condition Number:</strong> ${data.condition_number.toFixed(2)}</p>`;
            html += `<p><strong>Determinant:</strong> ${data.determinant.toExponential(3)}</p>`;
            html += '</div>';

            html += '</div>';

            content.innerHTML = html;
        }
    </script>
</body>
</html>
"""


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Visualize LED diffusion patterns")
    parser.add_argument(
        "--patterns",
        type=str,
        help="Path to patterns file (.npz) in new nested format",
    )
    parser.add_argument("--host", type=str, default="127.0.0.1", help="Host to bind to")
    parser.add_argument("--port", type=int, default=8080, help="Port to bind to")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")

    args = parser.parse_args()

    # Set up logging
    logging.basicConfig(
        level=logging.DEBUG if args.debug else logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Create visualizer
    visualizer = DiffusionPatternVisualizer(patterns_file=args.patterns)

    # Run the server
    visualizer.run(host=args.host, port=args.port, debug=args.debug)


if __name__ == "__main__":
    main()
